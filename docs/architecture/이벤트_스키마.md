# Event-Driven Architecture Schema

## 이벤트 토픽 명명 규칙

### 표준 형식
```
quantiq.<domain>.<event-type>
```

### 도메인별 토픽

#### Stock (주식 데이터)
```
quantiq.stock.price.updated       # 실시간 주가 업데이트
quantiq.stock.data.refreshed      # 주식 데이터 갱신 완료
quantiq.stock.data.sync.requested # 주식 데이터 동기화 요청
```

#### Trading (거래)
```
quantiq.trading.order.created     # 주문 생성
quantiq.trading.order.executed    # 주문 체결
quantiq.trading.order.cancelled   # 주문 취소
quantiq.trading.signal.detected   # 매매 신호 감지
quantiq.trading.balance.updated   # 계좌 잔고 업데이트
```

#### Analysis (분석)
```
quantiq.analysis.recommendation.generated  # 추천 생성 완료
quantiq.analysis.prediction.completed      # 예측 완료
quantiq.analysis.request                   # 분석 요청
quantiq.analysis.completed                 # 분석 완료
```

#### Economic (경제 데이터)
```
quantiq.economic.data.updated             # 경제 데이터 업데이트 완료
quantiq.economic.data.sync.requested      # 경제 데이터 동기화 요청
quantiq.economic.data.sync.failed         # 경제 데이터 동기화 실패
```

## Event Schema 표준

### 공통 Event 구조

```json
{
  "eventId": "uuid-v4",
  "eventType": "quantiq.stock.price.updated",
  "version": "1.0",
  "timestamp": "2026-01-31T10:30:00+09:00",
  "source": "quantiq-core",
  "payload": {
    // 도메인별 데이터
  }
}
```

### 필드 설명

| 필드 | 타입 | 필수 | 설명 |
|------|------|------|------|
| eventId | String (UUID) | ✅ | 이벤트 고유 식별자 |
| eventType | String | ✅ | 이벤트 타입 (토픽명과 동일) |
| version | String | ✅ | 이벤트 스키마 버전 |
| timestamp | String (ISO 8601) | ✅ | 이벤트 발생 시각 (KST) |
| source | String | ✅ | 이벤트 발행 서비스 |
| payload | Object | ✅ | 도메인별 이벤트 데이터 |

## 도메인별 Payload Schema

### Stock Events

#### quantiq.stock.price.updated
```json
{
  "eventId": "550e8400-e29b-41d4-a716-446655440000",
  "eventType": "quantiq.stock.price.updated",
  "version": "1.0",
  "timestamp": "2026-01-31T10:30:00+09:00",
  "source": "quantiq-data-engine",
  "payload": {
    "symbol": "AAPL",
    "price": 175.50,
    "change": 2.30,
    "changePercent": 1.33,
    "volume": 1234567,
    "marketCap": 2800000000000
  }
}
```

#### quantiq.stock.data.sync.requested
```json
{
  "eventId": "550e8400-e29b-41d4-a716-446655440001",
  "eventType": "quantiq.stock.data.sync.requested",
  "version": "1.0",
  "timestamp": "2026-01-31T10:30:00+09:00",
  "source": "quantiq-core",
  "payload": {
    "requestId": "req-1234567890",
    "symbols": ["AAPL", "GOOGL", "MSFT"],
    "syncType": "full|incremental",
    "priority": "high|normal|low"
  }
}
```

### Trading Events

#### quantiq.trading.order.created
```json
{
  "eventId": "550e8400-e29b-41d4-a716-446655440002",
  "eventType": "quantiq.trading.order.created",
  "version": "1.0",
  "timestamp": "2026-01-31T10:30:00+09:00",
  "source": "quantiq-core",
  "payload": {
    "orderId": "ORD-20260131-001",
    "userId": "user-123",
    "symbol": "AAPL",
    "orderType": "market|limit",
    "side": "buy|sell",
    "quantity": 100,
    "price": 175.50,
    "status": "pending"
  }
}
```

#### quantiq.trading.order.executed
```json
{
  "eventId": "550e8400-e29b-41d4-a716-446655440003",
  "eventType": "quantiq.trading.order.executed",
  "version": "1.0",
  "timestamp": "2026-01-31T10:30:05+09:00",
  "source": "quantiq-core",
  "payload": {
    "orderId": "ORD-20260131-001",
    "executedPrice": 175.48,
    "executedQuantity": 100,
    "commission": 0.50,
    "totalAmount": 17548.50
  }
}
```

#### quantiq.trading.signal.detected
```json
{
  "eventId": "550e8400-e29b-41d4-a716-446655440004",
  "eventType": "quantiq.trading.signal.detected",
  "version": "1.0",
  "timestamp": "2026-01-31T10:30:00+09:00",
  "source": "quantiq-data-engine",
  "payload": {
    "symbol": "AAPL",
    "signalType": "buy|sell",
    "confidence": 0.85,
    "indicators": {
      "rsi": 35.5,
      "macd": "bullish",
      "movingAverage": "golden_cross"
    },
    "recommendedAction": "buy",
    "recommendedQuantity": 100
  }
}
```

### Analysis Events

#### analysis.technical.request
```json
{
  "eventId": "550e8400-e29b-41d4-a716-446655440005",
  "eventType": "analysis.technical.request",
  "version": "1.0",
  "timestamp": "2026-01-31T23:30:00+09:00",
  "source": "quantiq-core",
  "payload": {
    "requestId": "req-tech-1234",
    "source": "quartz_scheduler",
    "timestamp": "2026-01-31T23:30:00+09:00",
    "threadTs": "1738339800.123456",
    "analysisType": "TECHNICAL"
  }
}
```

#### analysis.technical.completed
```json
{
  "eventId": "550e8400-e29b-41d4-a716-446655440006",
  "eventType": "analysis.technical.completed",
  "version": "1.0",
  "timestamp": "2026-01-31T23:30:15+09:00",
  "source": "quantiq-data-engine",
  "payload": {
    "requestId": "req-tech-1234",
    "status": "success",
    "duration": 15.2,
    "total_analyzed": 35,
    "recommended_count": 12,
    "results": [
      {
        "ticker": "AAPL",
        "composite_score": 75.5,
        "is_recommended": true,
        "sma_20": 175.50,
        "rsi": 45.2,
        "macd": "bullish"
      }
    ]
  }
}
```

#### analysis.sentiment.request
```json
{
  "eventId": "550e8400-e29b-41d4-a716-446655440007",
  "eventType": "analysis.sentiment.request",
  "version": "1.0",
  "timestamp": "2026-01-31T23:35:00+09:00",
  "source": "quantiq-core",
  "payload": {
    "requestId": "req-sentiment-1234",
    "source": "quartz_scheduler",
    "timestamp": "2026-01-31T23:35:00+09:00",
    "threadTs": "1738340100.234567",
    "analysisType": "SENTIMENT"
  }
}
```

#### analysis.sentiment.completed
```json
{
  "eventId": "550e8400-e29b-41d4-a716-446655440008",
  "eventType": "analysis.sentiment.completed",
  "version": "1.0",
  "timestamp": "2026-01-31T23:35:45+09:00",
  "source": "quantiq-data-engine",
  "payload": {
    "requestId": "req-sentiment-1234",
    "status": "success",
    "duration": 45.3,
    "total_analyzed": 22,
    "average_score": 0.1799,
    "results": [
      {
        "ticker": "AAPL",
        "average_sentiment_score": 0.139,
        "article_count": 50
      }
    ]
  }
}
```

#### analysis.combined.request
```json
{
  "eventId": "550e8400-e29b-41d4-a716-446655440009",
  "eventType": "analysis.combined.request",
  "version": "1.0",
  "timestamp": "2026-01-31T23:45:00+09:00",
  "source": "quantiq-core",
  "payload": {
    "requestId": "req-combined-1234",
    "source": "quartz_scheduler",
    "timestamp": "2026-01-31T23:45:00+09:00",
    "threadTs": "1738340700.345678",
    "analysisType": "COMBINED"
  }
}
```

#### analysis.completed
```json
{
  "eventId": "550e8400-e29b-41d4-a716-446655440010",
  "eventType": "analysis.completed",
  "version": "1.0",
  "timestamp": "2026-01-31T23:46:30+09:00",
  "source": "quantiq-data-engine",
  "payload": {
    "requestId": "req-combined-1234",
    "status": "success",
    "duration": 90.5,
    "technical_analyzed": 35,
    "technical_recommended": 12,
    "sentiment_analyzed": 22,
    "final_recommendations": 8,
    "recommendations": [
      {
        "ticker": "AAPL",
        "technical_score": 0.755,
        "sentiment_score": 0.139,
        "combined_score": 0.5703,
        "is_recommended": false
      },
      {
        "ticker": "TSM",
        "technical_score": 0.820,
        "sentiment_score": 0.360,
        "combined_score": 0.682,
        "is_recommended": true
      }
    ]
  }
}
```

**Slack 스레드 패턴 (threadTs)**
- `threadTs`: Slack 메시지 타임스탬프 (스레드 식별자)
- Kotlin에서 Slack 스레드 생성 후 threadTs 획득
- Kafka 메시지에 threadTs 포함하여 발행
- Python에서 threadTs를 사용하여 스레드 답글 형태로 진행상황 업데이트

**통합 분석 점수 계산식**
```
combined_score = (technical_score × 0.7) + (sentiment_normalized × 0.3)

where:
  technical_score = composite_score / 100.0  (0-100 → 0-1 정규화)
  sentiment_normalized = (sentiment_score + 1) / 2.0  (-1~1 → 0-1 정규화)

추천 기준: combined_score >= 0.6
```

### Economic Events

#### quantiq.economic.data.updated
```json
{
  "eventId": "550e8400-e29b-41d4-a716-446655440007",
  "eventType": "quantiq.economic.data.updated",
  "version": "1.0",
  "timestamp": "2026-01-31T10:30:00+09:00",
  "source": "quantiq-data-engine",
  "payload": {
    "requestId": "req-economic-1234",
    "dataTypes": ["gdp", "unemployment", "inflation"],
    "recordsUpdated": 150,
    "duration": 12.5,
    "status": "success"
  }
}
```

#### quantiq.economic.data.sync.requested
```json
{
  "eventId": "550e8400-e29b-41d4-a716-446655440008",
  "eventType": "quantiq.economic.data.sync.requested",
  "version": "1.0",
  "timestamp": "2026-01-31T10:30:00+09:00",
  "source": "quantiq-core",
  "payload": {
    "requestId": "req-economic-1234",
    "dataTypes": ["gdp", "unemployment", "inflation"],
    "source": "scheduled|manual",
    "priority": "normal"
  }
}
```

## Error Event Schema

에러 이벤트는 `.failed` 접미사를 사용합니다.

```json
{
  "eventId": "550e8400-e29b-41d4-a716-446655440009",
  "eventType": "quantiq.economic.data.sync.failed",
  "version": "1.0",
  "timestamp": "2026-01-31T10:30:00+09:00",
  "source": "quantiq-data-engine",
  "payload": {
    "requestId": "req-economic-1234",
    "errorCode": "API_RATE_LIMIT",
    "errorMessage": "FRED API rate limit exceeded",
    "retryable": true,
    "retryAfter": 60
  }
}
```

## Event Flow Patterns

### 1. Request-Response Pattern
```
quantiq-core → quantiq.economic.data.sync.requested → quantiq-data-engine
quantiq-data-engine → quantiq.economic.data.updated → quantiq-core
```

### 2. Fire-and-Forget Pattern
```
quantiq-core → quantiq.trading.order.created → (no response)
```

### 3. Event Chain Pattern
```
quantiq.stock.price.updated
  → quantiq.analysis.request
  → quantiq.analysis.recommendation.generated
  → quantiq.trading.signal.detected
  → quantiq.trading.order.created
```

## 구현 가이드

### Kotlin (quantiq-core)

```kotlin
// Event Schema
data class BaseEvent(
    val eventId: String = UUID.randomUUID().toString(),
    val eventType: String,
    val version: String = "1.0",
    val timestamp: String = ZonedDateTime.now(ZoneId.of("Asia/Seoul")).toString(),
    val source: String = "quantiq-core",
    val payload: Any
)

// Event Publisher
@Service
class EventPublisher(private val kafkaTemplate: KafkaTemplate<String, String>) {
    fun publish(topic: String, event: BaseEvent) {
        kafkaTemplate.send(topic, objectMapper.writeValueAsString(event))
    }
}
```

### Python (quantiq-data-engine)

```python
# Event Schema
@dataclass
class BaseEvent:
    eventId: str = field(default_factory=lambda: str(uuid.uuid4()))
    eventType: str
    version: str = "1.0"
    timestamp: str = field(default_factory=lambda: datetime.now(KST).isoformat())
    source: str = "quantiq-data-engine"
    payload: dict

# Event Publisher
class EventPublisher:
    @staticmethod
    def publish(topic: str, event: BaseEvent):
        producer.produce(topic, json.dumps(asdict(event)))
```

## 마이그레이션 계획

### Phase 1: 기존 토픽 유지 + 새 토픽 추가
- 기존: `economic.data.update.request`
- 신규: `quantiq.economic.data.sync.requested`
- 양쪽 모두 발행하여 호환성 유지

### Phase 2: 새 토픽으로 전환
- 모든 코드가 새 토픽을 사용하도록 수정
- 기존 토픽은 deprecated 표시

### Phase 3: 기존 토픽 제거
- 기존 토픽 구독 및 발행 코드 제거
- Kafka에서 토픽 삭제

---

**작성일**: 2026-01-31
**버전**: 1.0
**관리**: Quantiq Development Team
