# 데이터베이스 설계

**목적**: QuantIQ 데이터베이스 아키텍처 및 스키마 설계 문서
**대상**: 개발자, 데이터베이스 관리자
**작성일**: 2026-01-31

---

## 📋 목차

1. [Polyglot Persistence 전략](#polyglot-persistence-전략)
2. [데이터 매핑](#데이터-매핑)
3. [스키마 설계](#스키마-설계)
4. [마이그레이션 전략](#마이그레이션-전략)

---

## Polyglot Persistence 전략

QuantIQ는 **Polyglot Persistence** 전략을 채택하여 데이터의 특성에 따라 최적의 데이터베이스를 사용합니다.

### 전략 개요

- **PostgreSQL**: 관계형 무결성이 필요한 트랜잭션 데이터
- **MongoDB**: 유연한 스키마가 필요한 분석 데이터 및 마스터 데이터

### 선택 기준

| 기준 | PostgreSQL | MongoDB |
|------|-----------|---------|
| **데이터 구조** | 정형화된 테이블 구조 | 유연한 문서 구조 |
| **트랜잭션** | ACID 트랜잭션 필수 | 트랜잭션 불필요 |
| **관계** | 복잡한 JOIN 필요 | 임베디드 문서로 해결 |
| **확장성** | 수직 확장 중심 | 수평 확장 용이 |
| **변경 빈도** | 스키마 변경 적음 | 스키마 변경 빈번 |

---

## 데이터 매핑

### PostgreSQL 저장 데이터

| 엔티티 | 테이블명 | 이유 |
|--------|---------|------|
| **사용자** | `users` | 트랜잭션 데이터로 높은 일관성과 ACID 준수 필요 |
| **KIS 토큰** | `kis_tokens` | 인증 토큰 관리, 보안 및 무결성 중요 |
| **거래 설정** | `trading_configs` | 사용자별 거래 파라미터, 정형화된 구조 |
| **계좌 잔고** | `account_balances` | 금융 데이터, 트랜잭션 보장 필수 |
| **거래 내역** | `trades` | 매매 기록, 감사 추적 필요 |
| **보유 종목** | `stock_holdings` | 포트폴리오 관리, 실시간 잔고 추적 |
| **경제 데이터** | `economic_indicators` | 거시경제 지표 (FRED API) |

### MongoDB 저장 데이터

| 컬렉션 | 이름 | 이유 |
|-------|------|------|
| **종목 마스터** | `stock_master` | 글로벌 종목 목록 및 메타데이터, 유연한 속성 |
| **추천 신호** | `stock_recommendations` | 통합 신호 (매수/매도/대기), 분석 결과 |
| **기술적 분석** | `stock_analysis` | 상세한 기술적 지표 및 감정 분석 페이로드 |
| **감정 분석** | `ticker_sentiment_analysis` | 뉴스 및 소셜 미디어 감정도 |
| **일일 데이터** | `daily_stock_data` | 일일 통합 주가 데이터 |

---

## 스키마 설계

### PostgreSQL 테이블

#### 1. users (사용자)

```sql
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    user_id VARCHAR(50) UNIQUE NOT NULL,
    name VARCHAR(100),
    email VARCHAR(100),
    status VARCHAR(20) DEFAULT 'ACTIVE',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_user_id ON users(user_id);
CREATE INDEX idx_users_status ON users(status);
```

#### 2. kis_tokens (KIS API 토큰)

```sql
CREATE TABLE kis_tokens (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    access_token TEXT NOT NULL,
    refresh_token TEXT,
    token_type VARCHAR(20) DEFAULT 'Bearer',
    expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE INDEX idx_kis_tokens_user_id ON kis_tokens(user_id);
CREATE INDEX idx_kis_tokens_expires_at ON kis_tokens(expires_at);
```

#### 3. trading_configs (거래 설정)

```sql
CREATE TABLE trading_configs (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL UNIQUE,
    enabled BOOLEAN DEFAULT FALSE,
    auto_trading_enabled BOOLEAN DEFAULT FALSE,
    min_composite_score DECIMAL(5,2),
    max_stocks_to_buy INT,
    max_amount_per_stock DECIMAL(12,2),
    stop_loss_percent DECIMAL(5,2),
    take_profit_percent DECIMAL(5,2),
    trailing_stop_percent DECIMAL(5,2),
    budget_limit DECIMAL(15,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE INDEX idx_trading_configs_enabled ON trading_configs(user_id, enabled);
```

#### 4. account_balances (계좌 잔고)

```sql
CREATE TABLE account_balances (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL UNIQUE,
    cash DECIMAL(15,2) NOT NULL DEFAULT 0,
    total_value DECIMAL(15,2) NOT NULL DEFAULT 0,
    locked_cash DECIMAL(15,2) DEFAULT 0,
    overseas_balance DECIMAL(15,2) DEFAULT 0,
    local_balance DECIMAL(15,2) DEFAULT 0,
    version BIGINT DEFAULT 0,  -- Optimistic Locking
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE INDEX idx_account_balances_user ON account_balances(user_id);
```

#### 5. trades (거래 내역)

```sql
CREATE TABLE trades (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    ticker VARCHAR(10) NOT NULL,
    side VARCHAR(10) NOT NULL CHECK (side IN ('BUY', 'SELL')),
    quantity INT NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    total_amount DECIMAL(15,2) NOT NULL,
    status VARCHAR(20) DEFAULT 'PENDING',
    kis_order_id VARCHAR(100),
    executed_at TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE INDEX idx_trades_user_date ON trades(user_id, created_at DESC);
CREATE INDEX idx_trades_ticker ON trades(ticker);
CREATE INDEX idx_trades_status ON trades(status);
```

#### 6. stock_holdings (보유 종목)

```sql
CREATE TABLE stock_holdings (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    ticker VARCHAR(10) NOT NULL,
    quantity INT NOT NULL,
    avg_purchase_price DECIMAL(10,2) NOT NULL,
    current_price DECIMAL(10,2),
    total_value DECIMAL(15,2),
    profit_loss DECIMAL(15,2),
    profit_loss_percent DECIMAL(5,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    UNIQUE(user_id, ticker)
);

CREATE INDEX idx_stock_holdings_user ON stock_holdings(user_id);
CREATE INDEX idx_stock_holdings_ticker ON stock_holdings(ticker);
```

#### 7. economic_indicators (경제 지표)

```sql
CREATE TABLE economic_indicators (
    id BIGSERIAL PRIMARY KEY,
    indicator_code VARCHAR(50) NOT NULL,  -- FRED API 코드
    indicator_name VARCHAR(200) NOT NULL,
    value DECIMAL(15,4),
    date DATE NOT NULL,
    source VARCHAR(50) DEFAULT 'FRED',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(indicator_code, date)
);

CREATE INDEX idx_economic_indicators_code_date ON economic_indicators(indicator_code, date DESC);
CREATE INDEX idx_economic_indicators_date ON economic_indicators(date DESC);
```

### MongoDB 컬렉션

#### 1. stock_master (종목 마스터)

```javascript
{
  "_id": ObjectId("..."),
  "ticker": "AAPL",
  "name": "Apple Inc.",
  "exchange": "NASDAQ",
  "sector": "Technology",
  "industry": "Consumer Electronics",
  "market_cap": 3000000000000,
  "country": "US",
  "currency": "USD",
  "is_active": true,
  "metadata": {
    "ceo": "Tim Cook",
    "employees": 164000,
    "founded": "1976-04-01"
  },
  "created_at": ISODate("2026-01-31T00:00:00Z"),
  "updated_at": ISODate("2026-01-31T00:00:00Z")
}
```

**인덱스:**
```javascript
db.stock_master.createIndex({ "ticker": 1 }, { unique: true })
db.stock_master.createIndex({ "exchange": 1, "is_active": 1 })
db.stock_master.createIndex({ "sector": 1, "industry": 1 })
```

#### 2. stock_recommendations (추천 신호)

```javascript
{
  "_id": ObjectId("..."),
  "ticker": "AAPL",
  "date": "2026-01-31",
  "is_recommended": true,
  "signal_type": "BUY",  // BUY, SELL, HOLD
  "composite_score": 8.5,
  "technical_score": 9.0,
  "sentiment_score": 8.0,
  "signals": {
    "golden_cross": true,
    "rsi_oversold": false,
    "macd_buy": true
  },
  "current_price": 185.50,
  "target_price": 200.00,
  "stop_loss": 175.00,
  "confidence": "HIGH",  // HIGH, MEDIUM, LOW
  "created_at": ISODate("2026-01-31T00:00:00Z"),
  "updated_at": ISODate("2026-01-31T00:00:00Z")
}
```

**인덱스:**
```javascript
db.stock_recommendations.createIndex({ "ticker": 1, "date": -1 })
db.stock_recommendations.createIndex({ "date": -1, "is_recommended": 1 })
db.stock_recommendations.createIndex({ "composite_score": -1 })
```

#### 3. stock_analysis (분석 결과)

```javascript
{
  "_id": ObjectId("..."),
  "ticker": "AAPL",
  "date": "2026-01-31",
  "analysis_type": "TECHNICAL",  // TECHNICAL, SENTIMENT, FUNDAMENTAL
  "indicators": {
    "sma_20": 182.50,
    "sma_50": 178.30,
    "sma_200": 170.20,
    "rsi_14": 65.5,
    "macd": {
      "value": 2.5,
      "signal": 2.0,
      "histogram": 0.5
    },
    "bollinger_bands": {
      "upper": 190.00,
      "middle": 185.00,
      "lower": 180.00
    }
  },
  "signals": ["GOLDEN_CROSS", "MACD_BUY"],
  "raw_data": {
    // 원본 데이터
  },
  "created_at": ISODate("2026-01-31T00:00:00Z")
}
```

**인덱스:**
```javascript
db.stock_analysis.createIndex({ "ticker": 1, "date": -1, "analysis_type": 1 })
db.stock_analysis.createIndex({ "date": -1 })
```

#### 4. ticker_sentiment_analysis (감정 분석)

```javascript
{
  "_id": ObjectId("..."),
  "ticker": "AAPL",
  "date": "2026-01-31",
  "sentiment_score": 0.75,  // -1.0 ~ 1.0
  "sentiment_label": "POSITIVE",  // POSITIVE, NEUTRAL, NEGATIVE
  "news_count": 25,
  "sources": {
    "news": {
      "score": 0.8,
      "count": 15
    },
    "social": {
      "score": 0.7,
      "count": 10
    }
  },
  "keywords": ["iPhone", "AI", "revenue"],
  "created_at": ISODate("2026-01-31T00:00:00Z")
}
```

**인덱스:**
```javascript
db.ticker_sentiment_analysis.createIndex({ "ticker": 1, "date": -1 })
db.ticker_sentiment_analysis.createIndex({ "sentiment_score": -1 })
```

#### 5. daily_stock_data (일일 데이터)

```javascript
{
  "_id": ObjectId("..."),
  "ticker": "AAPL",
  "date": "2026-01-31",
  "open": 184.00,
  "high": 186.50,
  "low": 183.50,
  "close": 185.50,
  "volume": 75000000,
  "adj_close": 185.50,
  "change": 1.50,
  "change_percent": 0.82,
  "created_at": ISODate("2026-01-31T00:00:00Z")
}
```

**인덱스:**
```javascript
db.daily_stock_data.createIndex({ "ticker": 1, "date": -1 })
db.daily_stock_data.createIndex({ "date": -1 })
```

---

## 마이그레이션 전략

### 현재 상태 (Phase 2 완료)

- ✅ PostgreSQL 테이블 생성 완료
- ✅ MongoDB 컬렉션 구조 설계 완료
- ✅ Flyway 마이그레이션 스크립트 작성
- ⚠️ 데이터 이관 진행 중

### 마이그레이션 단계

#### Phase 1: PostgreSQL 스키마 생성 (완료)

```bash
# Flyway 마이그레이션 파일
V1__Initial_Schema.sql       # 기본 테이블 생성
V2__Create_Indexes.sql       # 인덱스 생성
V3__Create_Quartz_Tables.sql # Quartz 스케줄러 테이블
```

#### Phase 2: MongoDB 데이터 정리 (진행 중)

- MongoDB에서 PostgreSQL로 이관할 데이터 식별
- 중복 데이터 제거 및 정리
- 데이터 검증

#### Phase 3: 데이터 이관 (예정)

```kotlin
// RdbMigrationService를 통한 데이터 이관
@Service
class RdbMigrationService {
    @Transactional
    fun migrateUsers() {
        // MongoDB users → PostgreSQL users
    }

    @Transactional
    fun migrateTradingConfigs() {
        // MongoDB trading_configs → PostgreSQL trading_configs
    }
}
```

#### Phase 4: 이중 쓰기 모드 (예정)

- PostgreSQL과 MongoDB에 동시 쓰기
- 데이터 일관성 검증
- 모니터링 기간: 1주일

#### Phase 5: MongoDB 단계적 제거 (예정)

- 트랜잭션 데이터는 PostgreSQL에서만 읽기
- MongoDB는 분석 데이터만 유지
- 최종적으로 MongoDB는 캐시 용도로만 사용

---

## 데이터 무결성 규칙

### Foreign Key 제약

- **users**: 모든 테이블의 기준점
- **CASCADE DELETE**: 사용자 삭제 시 관련 데이터 자동 삭제
- **UNIQUE 제약**: 중복 방지 (user_id, ticker 조합 등)

### Optimistic Locking

```sql
-- account_balances 테이블의 version 컬럼 사용
UPDATE account_balances
SET cash = cash - 1000,
    version = version + 1
WHERE user_id = ? AND version = ?;

-- version이 일치하지 않으면 동시성 충돌 감지
```

### 트랜잭션 격리 수준

```yaml
spring:
  datasource:
    hikari:
      transaction-isolation: TRANSACTION_READ_COMMITTED
```

---

## 성능 최적화

### 인덱스 전략

- **복합 인덱스**: 자주 함께 조회되는 컬럼
- **부분 인덱스**: 조건부 인덱스 (status = 'ACTIVE')
- **커버링 인덱스**: SELECT 절의 모든 컬럼 포함

### 쿼리 최적화

```sql
-- ❌ 비효율적인 쿼리
SELECT * FROM trades WHERE user_id = 1;

-- ✅ 최적화된 쿼리
SELECT id, ticker, side, quantity, price
FROM trades
WHERE user_id = 1
ORDER BY created_at DESC
LIMIT 100;
```

### 파티셔닝 (미래)

```sql
-- trades 테이블 월별 파티셔닝
CREATE TABLE trades_2026_01 PARTITION OF trades
FOR VALUES FROM ('2026-01-01') TO ('2026-02-01');
```

---

## 백업 및 복구

### PostgreSQL 백업

```bash
# 전체 백업
docker-compose exec postgresql pg_dump -U quantiq_user quantiq > backup.sql

# 특정 테이블만 백업
docker-compose exec postgresql pg_dump -U quantiq_user -t users quantiq > users_backup.sql
```

### MongoDB 백업

```bash
# 전체 백업
docker-compose exec mongodb mongodump --db quantiq --out /backup

# 특정 컬렉션만 백업
docker-compose exec mongodb mongodump --db quantiq --collection stock_recommendations
```

---

## 관련 문서

- [스케줄러 마이그레이션 TODO](../todo/스케줄러_마이그레이션_TODO.md)
- [데이터베이스 마이그레이션 TODO](../todo/데이터베이스_마이그레이션_TODO.md)
- [이벤트 기반 아키텍처](./EVENT_DRIVEN_GUIDE.md)
- [시스템 아키텍처](./ARCHITECTURE.md)

---

**마지막 업데이트**: 2026-01-31
**버전**: 2.0 (한글화 및 상세화)
**작성자**: QuantIQ Development Team
